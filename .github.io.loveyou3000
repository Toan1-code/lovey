<html>
<body>
<!--StartFragment-->
Â  | <script type="text/javascript">
-- | --
Â  | var gk_isXlsx = false;
Â  | var gk_xlsxFileLookup = {};
Â  | var gk_fileData = {};
Â  | function filledCell(cell) {
Â  | return cell !== '' && cell != null;
Â  | }
Â  | function loadFileData(filename) {
Â  | if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
Â  | try {
Â  | var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
Â  | var firstSheetName = workbook.SheetNames[0];
Â  | var worksheet = workbook.Sheets[firstSheetName];
Â  | Â 
Â  | // Convert sheet to JSON to filter blank rows
Â  | var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
Â  | // Filter out blank rows (rows where all cells are empty, null, or undefined)
Â  | var filteredData = jsonData.filter(row => row.some(filledCell));
Â  | Â 
Â  | // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
Â  | var headerRowIndex = filteredData.findIndex((row, index) =>
Â  | row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
Â  | );
Â  | // Fallback
Â  | if (headerRowIndex === -1 \|\| headerRowIndex > 25) {
Â  | headerRowIndex = 0;
Â  | }
Â  | Â 
Â  | // Convert filtered JSON back to CSV
Â  | var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
Â  | csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
Â  | return csv;
Â  | } catch (e) {
Â  | console.error(e);
Â  | return "";
Â  | }
Â  | }
Â  | return gk_fileData[filename] \|\| "";
Â  | }
Â  | </script><!DOCTYPE html>
Â  | <html lang="en">
Â  | <head>
Â  | 
Â  | <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
Â  | <title>Hiá»‡u á»¨ng Chá»¯ RÆ¡i 3D</title>
Â  | <style>
Â  | body {
Â  | margin: 0;
Â  | padding: 0;
Â  | overflow: hidden;
Â  | height: 100vh;
Â  | width: 100vw;
Â  | font-family: 'Arial', sans-serif;
Â  | perspective: 1000px;
Â  | background-color: #000000;
Â  | touch-action: none;
Â  | }
Â  | #scene {
Â  | position: fixed;
Â  | top: 0;
Â  | left: 0;
Â  | width: 100%;
Â  | height: 100%;
Â  | transform-style: preserve-3d;
Â  | transition: transform 0.15s ease-out;
Â  | }
Â  | .falling-text, .heart, .rose {
Â  | position: absolute;
Â  | pointer-events: none;
Â  | transform-style: preserve-3d;
Â  | }
Â  | .falling-text {
Â  | color: #ff69b4;
Â  | font-size: 5vw;
Â  | white-space: nowrap;
Â  | opacity: 0.9;
Â  | text-shadow: 0 0 5px rgba(255, 105, 180, 0.8),
Â  | 0 0 10px rgba(255, 105, 180, 0.6);
Â  | animation: fadeInOut 2s infinite alternate;
Â  | }
Â  | .heart {
Â  | color: #ff1493;
Â  | font-size: 5vw;
Â  | opacity: 0.9;
Â  | text-shadow: 0 0 3px #ff1493, 0 0 5px #ff1493;
Â  | animation: float 4s infinite ease-in-out;
Â  | }
Â  | .rose {
Â  | color: #ff4040;
Â  | font-size: 4vw;
Â  | opacity: 0.9;
Â  | transform: rotate(45deg);
Â  | text-shadow: 0 0 3px #ff4040, 0 0 5px #ff4040;
Â  | animation: float 4s infinite ease-in-out;
Â  | }
Â  | /* Äá»‹nh nghÄ©a cÃ¡c lá»›p vá»›i Ä‘á»™ sÃ¢u vÃ  kiá»ƒu khÃ¡c nhau */
Â  | .layer-1 { transform: translateZ(-300px); opacity: 0.8; font-size: 3vw; }
Â  | .layer-2 { transform: translateZ(-150px); opacity: 0.85; font-size: 4vw; }
Â  | .layer-3 { transform: translateZ(0px); opacity: 0.9; font-size: 5vw; }
Â  | .layer-4 { transform: translateZ(150px); opacity: 0.95; font-size: 6vw; }
Â  | .layer-5 { transform: translateZ(300px); opacity: 1; font-size: 7vw; }
Â  | Â 
Â  | @keyframes fadeInOut {
Â  | from { opacity: 0.9; }
Â  | to { opacity: 0.6; }
Â  | }
Â  | @keyframes float {
Â  | 0%, 100% { transform: translateY(0); }
Â  | 50% { transform: translateY(-5px); }
Â  | }
Â  | @media (max-width: 768px) {
Â  | .falling-text {
Â  | font-size: 6vw;
Â  | }
Â  | .heart {
Â  | font-size: 6vw;
Â  | }
Â  | .rose {
Â  | font-size: 5vw;
Â  | }
Â  | .layer-1 { font-size: 4vw; }
Â  | .layer-2 { font-size: 5vw; }
Â  | .layer-3 { font-size: 6vw; }
Â  | .layer-4 { font-size: 7vw; }
Â  | .layer-5 { font-size: 8vw; }
Â  | }
Â  | </style>
Â  | </head>
Â  | <body>
Â  | <div id="scene"></div>
Â  | <audio id="backgroundMusic" loop>
Â  | <source src="https://nhatlinh04.github.io/to_tinh_niu/Ni%20Ny%20C%20Anh%20Lyrics%20Video.mp3" type="audio/mpeg">
Â  | TrÃ¬nh duyá»‡t cá»§a báº¡n khÃ´ng há»— trá»£ tháº» Ã¢m thanh.
Â  | </audio>
Â  | <script>
Â  | const texts = [
Â  | " ğŸ’Œ ğŸ’Œ YÃªu BÃ© cá»§a Anh ğŸ’•",
Â  | "LÃ m ngÆ°á»i yÃªu anh nhÃ©ğŸ’•",
Â  | "YÃªu BÃ© HÃ  Nhiá»uğŸ’•",
Â  | "anh yÃªu em",
Â  | "Anh yÃªu HÃ  nhiá»u láº¯m",
Â  | "YÃªu cá»¥c cÆ°ng cá»§a anhğŸ’•",
Â  | ];
Â  | Â 
Â  | const scene = document.getElementById("scene");
Â  | const audio = document.getElementById("backgroundMusic");
Â  | let rotateX = 0, rotateY = 0;
Â  | let targetRotateX = 0, targetRotateY = 0;
Â  | let lastTouchX = 0, lastTouchY = 0;
Â  | let lastMouseX = 0, lastMouseY = 0;
Â  | let isDragging = false;
Â  | const maxTexts = 15;
Â  | let activeTexts = [];
Â  | Â 
Â  | function checkCollision(newX, newY, newWidth, newHeight) {
Â  | for (let text of activeTexts) {
Â  | const rect = text.getBoundingClientRect();
Â  | if (newX < rect.right && newX + newWidth > rect.left &&
Â  | newY < rect.bottom && newY + newHeight > rect.top) {
Â  | return true;
Â  | }
Â  | }
Â  | return false;
Â  | }
Â  | Â 
Â  | document.addEventListener("touchstart", (e) => {
Â  | e.preventDefault();
Â  | lastTouchX = e.touches[0].clientX;
Â  | lastTouchY = e.touches[0].clientY;
Â  | isDragging = true;
Â  | if (audio.paused) {
Â  | audio.play().catch(err => console.log("KhÃ´ng thá»ƒ phÃ¡t tá»± Ä‘á»™ng:", err));
Â  | }
Â  | }, { passive: false });
Â  | Â 
Â  | document.addEventListener("touchmove", (e) => {
Â  | e.preventDefault();
Â  | const touchX = e.touches[0].clientX;
Â  | const touchY = e.touches[0].clientY;
Â  | Â 
Â  | const deltaX = (touchX - lastTouchX) * 0.5;
Â  | const deltaY = (touchY - lastTouchY) * 0.5;
Â  | Â 
Â  | targetRotateY += deltaX;
Â  | targetRotateX -= deltaY;
Â  | Â 
Â  | lastTouchX = touchX;
Â  | lastTouchY = touchY;
Â  | }, { passive: false });
Â  | Â 
Â  | document.addEventListener("touchend", () => {
Â  | isDragging = false;
Â  | targetRotateX = 0;
Â  | targetRotateY = 0;
Â  | });
Â  | Â 
Â  | document.addEventListener("mousedown", (e) => {
Â  | lastMouseX = e.clientX;
Â  | lastMouseY = e.clientY;
Â  | isDragging = true;
Â  | });
Â  | Â 
Â  | document.addEventListener("mousemove", (e) => {
Â  | if (isDragging) {
Â  | const deltaX = (e.clientX - lastMouseX) * 0.5;
Â  | const deltaY = (e.clientY - lastMouseY) * 0.5;
Â  | Â 
Â  | targetRotateY += deltaX;
Â  | targetRotateX += deltaY;
Â  | Â 
Â  | lastMouseX = e.clientX;
Â  | lastMouseY = e.clientY;
Â  | }
Â  | });
Â  | Â 
Â  | document.addEventListener("mouseup", () => {
Â  | isDragging = false;
Â  | targetRotateX = 0;
Â  | targetRotateY = 0;
Â  | });
Â  | Â 
Â  | function updateRotation() {
Â  | rotateX += (targetRotateX - rotateX) * 0.1;
Â  | rotateY += (targetRotateY - rotateY) * 0.1;
Â  | scene.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
Â  | requestAnimationFrame(updateRotation);
Â  | }
Â  | updateRotation();
Â  | Â 
Â  | function getRandomLayer() {
Â  | const layers = ['layer-1', 'layer-2', 'layer-3', 'layer-4', 'layer-5'];
Â  | return layers[Math.floor(Math.random() * layers.length)];
Â  | }
Â  | Â 
Â  | function createFallingText(initial = false) {
Â  | if (activeTexts.length >= maxTexts) return;
Â  | Â 
Â  | const text = document.createElement("div");
Â  | text.className = "falling-text";
Â  | text.innerText = texts[Math.floor(Math.random() * texts.length)];
Â  | Â 
Â  | let startX, startY;
Â  | const textWidth = text.offsetWidth \|\| 200;
Â  | const textHeight = text.offsetHeight \|\| 50;
Â  | let attempts = 0;
Â  | const maxAttempts = 10;
Â  | Â 
Â  | do {
Â  | startX = Math.random() * (window.innerWidth - textWidth);
Â  | startY = initial ? Math.random() * (window.innerHeight - textHeight) : -50;
Â  | attempts++;
Â  | } while (checkCollision(startX, startY, textWidth, textHeight) && attempts < maxAttempts);
Â  | Â 
Â  | if (attempts >= maxAttempts) {
Â  | startX = Math.random() * (window.innerWidth - textWidth);
Â  | startY = -50;
Â  | }
Â  | Â 
Â  | const layerClass = getRandomLayer();
Â  | text.classList.add(layerClass);
Â  | text.style.left = startX + "px";
Â  | text.style.top = startY + "px";
Â  | text.style.color = `hsl(${Math.random() * 360}, 80%, 70%)`;
Â  | Â 
Â  | scene.appendChild(text);
Â  | activeTexts.push(text);
Â  | Â 
Â  | let posY = startY;
Â  | const speed = Math.random() * 1 + 0.5;
Â  | Â 
Â  | function animate() {
Â  | posY += speed;
Â  | text.style.top = posY + "px";
Â  | Â 
Â  | if (posY > window.innerHeight + 50) {
Â  | text.remove();
Â  | activeTexts = activeTexts.filter(t => t !== text);
Â  | } else {
Â  | requestAnimationFrame(animate);
Â  | }
Â  | }
Â  | animate();
Â  | }
Â  | Â 
Â  | function createHeart(initial = false) {
Â  | const layers = ['layer-1', 'layer-2', 'layer-3', 'layer-4', 'layer-5'];
Â  | Â 
Â  | layers.forEach(layerClass => {
Â  | const heart = document.createElement("div");
Â  | heart.className = "heart";
Â  | heart.innerText = "â™¥";
Â  | Â 
Â  | const startX = Math.random() * window.innerWidth;
Â  | heart.classList.add(layerClass);
Â  | heart.style.left = startX + "px";
Â  | heart.style.top = initial ? (Math.random() * window.innerHeight) + "px" : "-50px";
Â  | Â 
Â  | scene.appendChild(heart);
Â  | Â 
Â  | let posY = initial ? parseFloat(heart.style.top) : -50;
Â  | const speed = Math.random() * 0.8 + 0.4;
Â  | Â 
Â  | function animateHeart() {
Â  | posY += speed;
Â  | heart.style.top = posY + "px";
Â  | Â 
Â  | if (posY > window.innerHeight + 50) {
Â  | heart.remove();
Â  | } else {
Â  | requestAnimationFrame(animateHeart);
Â  | }
Â  | }
Â  | animateHeart();
Â  | });
Â  | }
Â  | Â 
Â  | function createRose(initial = false) {
Â  | const rose = document.createElement("div");
Â  | rose.className = "rose";
Â  | rose.innerText = "â™¥";
Â  | Â 
Â  | const startX = Math.random() * window.innerWidth;
Â  | const layerClass = getRandomLayer();
Â  | rose.classList.add(layerClass);
Â  | rose.style.left = startX + "px";
Â  | rose.style.top = initial ? (Math.random() * window.innerHeight) + "px" : "-50px";
Â  | Â 
Â  | scene.appendChild(rose);
Â  | Â 
Â  | let posY = initial ? parseFloat(rose.style.top) : -50;
Â  | const speed = Math.random() * 0.8 + 0.4;
Â  | Â 
Â  | function animateRose() {
Â  | posY += speed;
Â  | rose.style.top = posY + "px";
Â  | Â 
Â  | if (posY > window.innerHeight + 50) {
Â  | rose.remove();
Â  | } else {
Â  | requestAnimationFrame(animateRose);
Â  | }
Â  | }
Â  | animateRose();
Â  | }
Â  | Â 
Â  | for (let i = 0; i < 8; i++) {
Â  | createFallingText(true);
Â  | }
Â  | for (let i = 0; i < 2; i++) {
Â  | createHeart(true);
Â  | }
Â  | for (let i = 0; i < 5; i++) {
Â  | createRose(true);
Â  | }
Â  | Â 
Â  | setInterval(createFallingText, 500);
Â  | setInterval(createHeart, 1500);
Â  | setInterval(createRose, 700);
Â  | </script>
Â  | </body>
Â  | </html>
Â  | Â 

<!--EndFragment-->
</body>
</html>
